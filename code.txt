if (random().nextBoolean()) {
    cluster.getSolrClient().commit(collection);}
    else {
      cluster.getSolrClient().optimize(collection);}
    final String matchingColorsCommaSep = matchingColors.toString().replaceAll("[ \\[\\]]", "");
    final String childQueryClause = "{!terms f=COLOR_s}" + matchingColorsCommaSep;
      final boolean oldFacetsEnabled = random().nextBoolean();
      final boolean limitJsonSizes = random().nextBoolean();
      final boolean limitJsonColors = random().nextBoolean();
      QueryRespon se results = query("q", "{!parent which=\"type_s:parent\" v=$matchingColors}",//+childQueryClause,
          "matchingColors", childQueryClause,
          "facet", oldFacetsEnabled ? "true":"false", // try to enforce multiple phases
              oldFacetsEnabled ? "facet.field" : "ignore" , "BRAND_s",
              oldFacetsEnabled&&usually() ? "facet.limit" : "ignore" , "1",
              oldFacetsEnabled&&usually() ? "facet.mincount" : "ignore" , "2",
              oldFacetsEnabled&&usually() ? "facet.overrequest.count" : "ignore" , "0",
          "qt",  random().nextBoolean() ? "/blockJoinDocSetFacetRH" : "/blockJoinFacetRH",
          "child.facet.field", "COLOR_s",
          "child.facet.field", "SIZE_s",
          "distrib.singlePass", random().nextBoolean() ? "true":"false",
          "rows", random().nextBoolean() ? "0":"10",
          "json.facet","{ "
              + "children:{ type: query, query:\"*:*\", domain:{"
                    +"blockChildren:\"type_s:parent\", filter:{param:matchingColors}"
                    + "}, facet:{ colors:{ type:field, field:COLOR_s,"
                    +              (limitJsonColors ? "":" limit:-1,")
                    +              " facet:{ inprods:\"uniqueBlock(_root_)\"}}, "
                    +         "sizes:{type:field, field:SIZE_s, "
                    +              (limitJsonSizes ? "" : "limit:-1,")
                    +              " facet:{inprods:\"uniqueBlock(_root_)\"}}"
                    + "}"
              + "}}", "debugQuery","true"//, "shards", "shard1"
          );
      NamedList<Object> resultsResponse = results.getResponse();
      assertNotNull(resultsResponse);
      FacetField color_s = results.getFacetField("COLOR_s");
      FacetField size_s = results.getFacetField("SIZE_s");
      String msg = ""+parentIdsByAttrValue+" "+color_s+" "+size_s;
      for (FacetField facet: new FacetField[]{color_s, size_s}) {
        for (Count c : facet.getValues()) {
          assertEquals(c.getName()+"("+msg+")",
              parentIdsByAttrValue.get(c.getName()).size(), c.getCount());
        }
      }
      assertEquals(msg , parentIdsByAttrValue.size(),color_s.getValueCount() + size_s.getValueCount());
      final List<NamedList<Object>> jsonSizes = (List<NamedList<Object>>)
                              get(resultsResponse, "facets", "children", "sizes", "buckets");
      final List<NamedList<Object>> jsonColors = (List<NamedList<Object>>)
                                get(resultsResponse, "facets", "children", "colors", "buckets");
      if (limitJsonColors) {
        assertTrue(""+jsonColors, jsonColors.size()<=defFacetLimit);
      }
      if (limitJsonSizes) {
        assertTrue(""+jsonSizes, jsonSizes.size()<=defFacetLimit);
      }
      for (List<NamedList<Object>> vals : new List[] { jsonSizes,jsonColors}) {
        int i=0;
        for(NamedList<Object> tuples: vals) {
          String  val = (String) get(tuples,"val");
          Number  count = (Number) get(tuples,"inprods");
          if (((vals==jsonSizes && limitJsonSizes) || // vals close to the limit are not exact
              (vals==jsonColors && limitJsonColors)) && i>=defFacetLimit/2) {
            assertTrue(i+ "th "+tuples+". "+vals,
                parentIdsByAttrValue.get(val).size()>= count.intValue() &&
                count.intValue()>0);
          } else {
            assertEquals(tuples+". "+vals,
                parentIdsByAttrValue.get(val).size(),count.intValue());
          }
          i++;
        }
      }
      if (!limitJsonColors && !limitJsonSizes) {
        assertEquals(""+jsonSizes+jsonColors, parentIdsByAttrValue.size(),jsonSizes.size() + jsonColors.size());
      }

The JSON Facet API currently has the ability to map between parents and children.
This issue is about adding a true rollup ability where parents would take on derived values from their children.
The most important part (and the most difficult part) will be the external API.

1 1
END